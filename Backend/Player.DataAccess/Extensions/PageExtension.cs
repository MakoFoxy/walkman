using System.Linq;

namespace Player.DataAccess.Extensions
{
    public static class PageExtension
    {
        public static IQueryable<T> GetPagedQuery<T>(this IQueryable<T> query, int? page, int? itemsPerPage)
        {
            if (page.HasValue && itemsPerPage.HasValue)
            {
                query = query.Skip((page.Value - 1) * itemsPerPage.Value).Take(itemsPerPage.Value);
            }

            return query;
        }
    }
}

// Класс PageExtension:

//     Этот класс объявлен как static, что является обязательным для классов, содержащих методы расширения. Методы расширения позволяют добавлять новые функции к существующим типам без создания новых производных классов, изменения исходных классов или использования техник наследования.

// Метод GetPagedQuery<T>:

//     Это статический метод расширения, что видно по ключевому слову this перед первым параметром IQueryable<T> query. Это означает, что метод может быть вызван как метод любого объекта, реализующего IQueryable<T>.
//     int? page и int? itemsPerPage являются параметрами, которые указывают номер страницы и количество элементов на странице соответственно. Они объявлены как nullable (с вопросительным знаком), что позволяет им принимать значения null, в случае, если пагинация не требуется.
//     Внутри метода, если оба параметра page и itemsPerPage имеют значения (не null), запрос модифицируется с использованием методов Skip() и Take(), что является стандартным способом реализации пагинации в LINQ. Это позволяет пропустить определенное количество элементов, соответствующее предыдущим страницам ((page.Value - 1) * itemsPerPage.Value), и затем взять следующие itemsPerPage.Value элементов для текущей страницы.
//     Метод возвращает модифицированный (или оригинальный, если пагинация не применяется) запрос типа IQueryable<T>, что позволяет дальше использовать его для извлечения данных.

// Применение:

// Этот метод расширения можно использовать для добавления пагинации к любому запросу LINQ в вашем приложении, что делает код более чистым и удобным для повторного использования. Например, вы можете использовать его следующим образом:

// csharp

// var pagedResults = dbContext.SomeEntities
//     .Where(...) // некоторые условия фильтрации
//     .OrderBy(...) // критерии сортировки
//     .GetPagedQuery(pageNumber, itemsPerPage)
//     .ToList();

// Это позволяет легко и эффективно реализовать разбивку результатов запроса на страницы, что особенно полезно при создании API, требующих пагинации данных, или при реализации пользовательских интерфейсов, отображающих списки данных постранично.
